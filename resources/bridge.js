// gemini/bridge.js

const OopisOS_Kernel = {
    isReady: false,
    pyodide: null,
    kernel: null,
    dependencies: null,
    _initPromise: null,
    _resolveInit: null,

    async syscall(module, func, args = [], kwargs = {}) {
        // If kernel isn't ready yet, wait for initialization to complete
        if (!this.isReady || !this.kernel) {
            if (this._initPromise) {
                try { await this._initPromise; } catch (_) { /* ignore */ }
            }
        }
        if (!this.isReady || !this.kernel) {
            return JSON.stringify({ "success": false, "error": "Error: Python kernel is not ready for syscall." });
        }
        try {
            const request = { module, "function": func, args, kwargs };
            const resultPromise = this.kernel.syscall_handler(JSON.stringify(request));
            return await resultPromise;
        } catch (error) {
            return JSON.stringify({ "success": false, "error": `Syscall bridge error: ${error.message}` });
        }
    },
    
    getKernelFileManifest() {
        const coreFiles = [
            "kernel", "filesystem", "executor", "session", "groups", "users",
            "sudo", "audit", "ai_manager", "time_utils", "story_manager"
        ];

        const appFiles = [
            "editor", "paint", "adventure", "top", "log", "basic"
        ];

        // This list can be automatically generated by a build script in the future
        const commandFiles = [
            "_upload_handler", "adventure", "agenda", "alias", "awk", "backup",
            "base64", "basic", "bc", "beep", "bg", "binder", "bulletin", "cast",
            "cat", "cd", "character", "check_fail", "chgrp", "chidi", "chmod",
            "chown", "cinematic", "cksum", "clear", "clearfs", "comm",
            "committee", "cp", "csplit", "cut", "date", "delay", "df", "diff",
            "du", "echo", "edit", "export", "expr", "fg", "find", "forge", "fsck",
            "gemini", "grep", "groupadd", "groupdel", "groups", "head", "help",
            "history", "jobs", "kill", "less", "listusers", "ln", "log", "login",
            "logout", "ls", "man", "mkdir", "more", "mv", "nc", "netstat", "nl",
            "ocrypt", "paint", "passwd", "patch", "planner", "play",
            "post_message", "printf", "printscreen", "ps", "pwd", "read_messages",
            "reboot", "remix", "removeuser", "rename", "reset", "restore",
            "ritual", "rm", "rmdir", "roll", "run", "score", "sed", "set", "shuf",
            "sort", "story", "storyboard", "su", "sudo", "sync", "tail", "theme", "top",
            "touch", "tr", "tree", "unalias", "uniq", "unset", "unzip", "upload",
            "uptime", "useradd", "usermod", "visudo", "wc", "who", "whoami",
            "xargs", "xor", "zip"
        ];

        const manifest = {};

        // Core services
        for (const file of coreFiles) {
            manifest[`/core/${file}.py`] = `./core/${file}.py`;
        }

        // Core directories and __init__.py files
        manifest['/core/commands/__init__.py'] = null;
        manifest['/core/apps/__init__.py'] = null;


        // App modules
        for (const file of appFiles) {
            manifest[`/core/apps/${file}.py`] = `./core/apps/${file}.py`;
        }
        manifest[`/core/apps/gemini_chat.py`] = null; // Still needed to avoid import errors

        // Command modules
        for (const file of commandFiles) {
            manifest[`/core/commands/${file}.py`] = `./core/commands/${file}.py`;
        }


        return manifest;
    },


    async initialize(dependencies) {
        this.dependencies = dependencies;
        const { OutputManager, Config } = this.dependencies;
        // Set up an initialization promise that other calls can await
        if (!this._initPromise) {
            this._initPromise = new Promise((resolve) => { this._resolveInit = resolve; });
        }
        try {
            await OutputManager.appendToOutput(`Initializing Python runtime via Pyodide (Browser Mode)...`, { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });

            let pyodideIndexURL = './dep/pyodide/';

            this.pyodide = await loadPyodide({
                indexURL: pyodideIndexURL
            });

            await this.pyodide.loadPackage(["cryptography", "ssl"]);
            await OutputManager.appendToOutput("Python runtime loaded. Loading kernel...", { typeClass: Config.CSS_CLASSES.CONSOLE_LOG_MSG });

            this.pyodide.FS.mkdir('/core');
            this.pyodide.FS.mkdir('/core/commands');
            this.pyodide.FS.mkdir('/core/apps');
            await this.pyodide.runPythonAsync(`import sys\\nsys.path.append('/core')`);

            // This is the new, refactored loading process!
            const filesToLoad = this.getKernelFileManifest();

            for (const [pyPath, jsPath] of Object.entries(filesToLoad)) {
                if (jsPath) {
                    let code;
                    // Browser: Use the original fetch method.
                    code = await (await fetch(jsPath)).text();
                    this.pyodide.FS.writeFile(pyPath, code, { encoding: 'utf8' });
                } else {
                    this.pyodide.FS.writeFile(pyPath, '', { encoding: 'utf8' });
                }
            }

            this.kernel = this.pyodide.pyimport("kernel");
            this.kernel.initialize_kernel(this.saveFileSystemToDB.bind(this));

            const pythonCommands = this.kernel.MODULE_DISPATCHER["executor"].commands.toJs();
            Config.COMMANDS_MANIFEST.push(...pythonCommands);
            Config.COMMANDS_MANIFEST.sort();

            // During initialization, call the Python syscall handler directly to avoid readiness gating deadlock
            try {
                const request = { module: "executor", "function": "set_js_native_commands", args: [Config.JS_NATIVE_COMMANDS], kwargs: {} };
                await this.kernel.syscall_handler(JSON.stringify(request));
            } catch (e) {
                console.warn("Failed to set JS native commands during init:", e);
            }

            this.isReady = true;
            await OutputManager.appendToOutput("OopisOS Python Kernel is online.", { typeClass: Config.CSS_CLASSES.SUCCESS_MSG });
            if (this._resolveInit) { this._resolveInit(); this._resolveInit = null; }
        } catch (error) {
            this.isReady = false;
            console.error("Pyodide initialization failed:", error);
            await OutputManager.appendToOutput(`FATAL: Python Kernel failed to load: ${error.message}`, { typeClass: Config.CSS_CLASSES.ERROR_MSG });
            if (this._resolveInit) { this._resolveInit(); this._resolveInit = null; }
        }
    },

    async execute_command(commandString, jsContextJson, stdinContent = null) {
        // Wait for initialization to complete if needed
        if (!this.isReady || !this.kernel) {
            if (this._initPromise) {
                try { await this._initPromise; } catch (_) { /* ignore */ }
            }
        }
        if (!this.isReady || !this.kernel) {
            return JSON.stringify({ "success": false, "error": "Kernel not ready." });
        }
        return await this.kernel.execute_command(commandString, jsContextJson, stdinContent);
    },

    async saveFileSystemToDB(fsJsonString) {
        const { StorageHAL } = OopisOS_Kernel.dependencies;
        try {
            const fsData = JSON.parse(fsJsonString);
            await StorageHAL.save(fsData);
        } catch (e) {
            console.error("JS Bridge: Failed to save filesystem state via kernel callback.", e);
        }
    }
};